# -*- coding: utf-8 -*-
"""Eight_puzzle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g6z5Dy_2QLpTrIzWqCyZoIaz1e4UQ3hn

# Pedro Vitor de Souza Dantas
# Solucionador do 8-Puzzle com Agentes Guiados a Objetivo

## Introdução

Este projeto apresenta a implementação de três agentes para resolver o problema do 8-puzzle, utilizando algoritmos clássicos de busca:

As celulas estão organizadas da seguinte forma, a primeiira está o código completo que será executado, em seguida as funções estão separadas para uma melhor explicação das mesmas.

- **Busca em Largura (BFS - Breadth-First Search)**
- **Busca em Profundidade (DFS - Depth-First Search)**
- **Busca por Aprofundamento Iterativo (IDS - Iterative Deepening Search)**
- **Busca gulosa**
- **Busca utilizando o A**

Cada movimento tem custo unitário e as ações geradas pela função sucessora sempre resultam em estados válidos. O objetivo do agente é transformar um estado inicial em um estado objetivo através de uma sequência mínima de movimentos.

As buscas são avaliadas em termos de:
- Custo da solução
- Nós expandidos
- Profundidade da solução
- Tempo de execução
- Uso de memória

---
# O código a seguir segue tal estrutura:
### Imports, classe Node, funções de movimentação e expansão
### Implementação de BFS, DFS e IDS, Guloso, A*
### Tabuleiro de teste
### Execução dos algoritmos

## Explicação do Funcionamento

- **Classe Node**: representa cada estado do tabuleiro. Guarda o estado, o nó pai (para reconstrução do caminho), a ação realizada e o custo.
- **Funções auxiliares**:
  - `chegou_objetivo`: verifica se o estado atual é o estado final.
  - `expandir`: gera os possíveis filhos de um nó movendo o espaço vazio (0).
- **BFS**: percorre os estados em largura, garantindo a menor solução possível. Pode consumir muita memória.
- **DFS**: busca em profundidade recursiva com limite. Menor uso de memória, mas pode não encontrar a solução.
- **IDS**: executa DFS com limites crescentes. Encontra soluções ótimas com menor uso de memória que BFS.

---

# O resultado final o tabuleiro é:


### Estado final:
```
[1, 2, 3]
[4, 5, 6]
[7, 8, 0]

```
# A seguir temos os casos de testes:
##[1, 3, 6, 5, 0, 2, 4, 7, 8]

=== Solução por BFS ===
Caminho da solução: direita -> cima -> esquerda -> baixo -> esquerda -> baixo -> direita -> direita
Custo da solução: 8
Nós expandidos: 311
Tamanho da fronteira: 190
Tamanho máximo da fronteira: 190
Profundidade da busca: 9
Profundidade máxima da busca: 9
Tempo de execução: 0.021288 segundos
Uso de memória: 100.34 MB

=== Solução por DFS (com pilha iterativa) ===
Caminho da solução: cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> cima -> direita -> direita -> baixo -> baixo -> esquerda -> cima -> esquerda -> cima -> direita -> baixo -> direita -> baixo
Custo da solução: 100
Nós expandidos: 100368
Profundidade máxima da busca: 100
Tempo de execução: 2.034564 segundos
Uso de memória: 128.75 MB

=== Solução por IDS (Busca Iterativa em Profundidade) ===
Caminho da solução: cima -> direita -> baixo -> esquerda -> cima -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita
Custo da solução: 12
Profundidade da solução: 12
Tempo de execução: 0.063092 segundos

---------------------------------------------------------------------------------------------------

##[7, 4, 0, 1, 2, 5, 6, 8, 3]

=== Solução por BFS ===
Caminho da solução: baixo -> esquerda -> esquerda -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo
Custo da solução: 20
Nós expandidos: 45629
Tamanho da fronteira: 17228
Tamanho máximo da fronteira: 17289
Profundidade da busca: 21
Profundidade máxima da busca: 21
Tempo de execução: 1.332135 segundos
Uso de memória: 143.27 MB

=== Solução por DFS (com pilha iterativa) ===
Caminho da solução: baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> direita -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> direita -> cima -> esquerda -> baixo -> direita -> direita -> baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> baixo -> direita
Custo da solução: 98
Nós expandidos: 44281
Profundidade máxima da busca: 100
Tempo de execução: 0.338363 segundos
Uso de memória: 143.27 MB

=== Solução por IDS (Busca Iterativa em Profundidade) ===
Caminho da solução: baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> baixo -> direita
Custo da solução: 26
Profundidade da solução: 26
Tempo de execução: 0.518088 segundos
Uso de memória: 138.58 MB


##[0, 5, 1, 6, 4, 3, 8, 2, 7]


=== Solução por BFS ===
Caminho da solução: baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> cima -> direita -> baixo -> esquerda -> baixo -> direita -> direita
Custo da solução: 24
Nós expandidos: 119087
Tamanho da fronteira: 23308
Tamanho máximo da fronteira: 24048
Profundidade da busca: 25
Profundidade máxima da busca: 25
Tempo de execução: 3.193469 segundos
Uso de memória: 186.79 MB

=== Solução por DFS (com pilha iterativa) ===
Caminho da solução: baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> baixo -> direita -> cima -> esquerda -> esquerda -> baixo -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> baixo -> direita
Custo da solução: 100
Nós expandidos: 53588
Profundidade máxima da busca: 100
Tempo de execução: 0.225635 segundos
Uso de memória: 186.79 MB

=== Solução por IDS (Busca Iterativa em Profundidade) ===
Caminho da solução: baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> esquerda -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> cima -> esquerda -> baixo -> direita -> baixo
Custo da solução: 30
Profundidade da solução: 30
Tempo de execução: 1.159473 segundos
Uso de memória: 157.77 MB

##[8, 7, 6, 5, 4, 3, 2, 1, 0]


=== Solução por BFS ===
Caminho da solução: cima -> esquerda -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> baixo -> direita
Custo da solução: 30
Nós expandidos: 181393
Tamanho da fronteira: 150
Tamanho máximo da fronteira: 24054
Profundidade da busca: 31
Profundidade máxima da busca: 31
Tempo de execução: 4.328634 segundos
Uso de memória: 196.95 MB

=== Solução por DFS (com pilha iterativa) ===
Caminho da solução: cima -> cima -> esquerda -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> direita -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> cima -> esquerda -> esquerda -> baixo -> direita -> direita -> baixo
Custo da solução: 100
Nós expandidos: 6979
Profundidade máxima da busca: 100
Tempo de execução: 0.029800 segundos
Uso de memória: 188.61 MB

=== Solução por IDS (Busca Iterativa em Profundidade) ===
Caminho da solução: cima -> esquerda -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> baixo -> direita
Custo da solução: 30
Profundidade da solução: 33
Tempo de execução: 2.203781 segundos
Uso de memória: 171.76 MB


---

### 📌 **Conclusão**

```markdown
## Conclusão

Com base nos experimentos realizados, é possível concluir que:

- **Busca em Largura (BFS)** encontra sempre a solução ótima, mas pode consumir muita memória em estados mais profundos.
- **Busca em Profundidade (DFS)** é mais leve em memória, porém pode não encontrar a solução ideal ou mesmo nenhuma, dependendo do limite.
- **Busca por Aprofundamento Iterativo (IDS)** combina o melhor dos dois mundos: encontra soluções ótimas com menor uso de memória, apesar de realizar buscas repetidas.

### ✅ Melhor algoritmo: **IDS**
- Encontrou a solução ótima
- Usou memória moderada
- Balanceou profundidade e tempo

### ❌ Pior algoritmo: **DFS**
- Apesar de rápido e leve, pode falhar em encontrar soluções, especialmente com limites mal definidos.

---
"""

import time
import psutil  # Biblioteca para medir uso de memória
from collections import deque

class Node:
    def __init__(self, estado, pai=None, acao="", custo=0):
        self.estado = estado
        self.pai = pai
        self.acao = acao
        self.custo = custo

# Direções e movimentos possíveis
movimentos = [(-1, 0), (1, 0), (0, -1), (0, 1)]
direcao = ["cima", "baixo", "esquerda", "direita"]

# Estado objetivo final
objetivo_final = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

def chegou_objetivo(estado):
    return estado == objetivo_final

def encontrar_zero(estado):
    for i in range(3):
        for j in range(3):
            if estado[i][j] == 0:
                return i, j
    return -1, -1

def expandir(node):
    filhos = []
    x, y = encontrar_zero(node.estado)

    for i in range(4):
        nx, ny = x + movimentos[i][0], y + movimentos[i][1]
        if 0 <= nx < 3 and 0 <= ny < 3:
            novo_estado = [linha[:] for linha in node.estado]  # Copia a matriz
            novo_estado[x][y], novo_estado[nx][ny] = novo_estado[nx][ny], novo_estado[x][y]
            filhos.append(Node(novo_estado, node, direcao[i], node.custo + 1))
    return filhos

def bfs(root):
    inicio_tempo = time.time()

    fronteira = deque([root])
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        node = fronteira.popleft()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                fronteira.append(filho)

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

def imprimir_caminho(node):
    if node is None:
        return []
    caminho = []
    while node.pai is not None:
        caminho.append(node.acao)
        node = node.pai
    caminho.reverse()
    return caminho

# DFS com pilha (iterativa)
def dfs(root, limite=100):
    inicio = time.time()
    pilha = [root]
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    max_search_depth = 0

    while pilha:
        node = pilha.pop()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo = time.time() - inicio
            memoria = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, max_search_depth, tempo, memoria

        if node.custo < limite:
            filhos = expandir(node)
            for filho in reversed(filhos):
                filho_estado = tuple(map(tuple, filho.estado))
                if filho_estado not in visitado:
                    visitado.add(filho_estado)
                    pilha.append(filho)
                    max_search_depth = max(max_search_depth, filho.custo)

    tempo = time.time() - inicio
    memoria = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, max_search_depth, tempo, memoria

# IDS com DFS limitada
def dls(root, limite):
    return dfs(root, limite)[0]  # Retorna apenas o node

def ids(root):
    inicio = time.time()
    profundidade_maxima = 100
    memoria = 0
    for limite in range(profundidade_maxima):
        resultado = dls(root, limite)
        memoria = psutil.Process().memory_info().rss / (1024 * 1024)
        if resultado:
            tempo = time.time() - inicio
            return resultado, limite, tempo, memoria
    return None, profundidade_maxima, time.time() - inicio, memoria

# Tabuleiro de entrada
tabuleiro = [
    [8, 7, 6],
    [5, 4, 3],
    [2, 1, 0]
]


raiz = Node(tabuleiro)

# Execução da BFS
solucao, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso = bfs(raiz)

# Execução da DFS
solucao_dfs, nodes_expanded_dfs, max_depth_dfs, tempo_dfs, memoria_dfs = dfs(raiz)

# Execução da IDS
solucao_ids, profundidade_ids, tempo_ids, memoria_ids = ids(raiz)

# Impressão dos resultados
if solucao:
    path_to_go_bfs = imprimir_caminho(solucao)
    cost_of_path_bfs = solucao.custo

    print("\n=== Solução por BFS ===")
    print(f"Caminho da solução: {' -> '.join(path_to_go_bfs)}")
    print(f"Custo da solução: {cost_of_path_bfs}")
    print(f"Nós expandidos: {nodes_expanded}")
    print(f"Tamanho da fronteira: {fringe_size}")
    print(f"Tamanho máximo da fronteira: {max_fringe_size}")
    print(f"Profundidade da busca: {search_depth}")
    print(f"Profundidade máxima da busca: {max_search_depth}")
    print(f"Tempo de execução: {tempo_decorrido:.6f} segundos")
    print(f"Uso de memória: {memoria_uso:.2f} MB")
else:
    print("Nenhuma solução encontrada utilizando BFS.")

if solucao_dfs:
    path_to_go_dfs = imprimir_caminho(solucao_dfs)
    cost_of_path_dfs = solucao_dfs.custo

    print("\n=== Solução por DFS (com pilha iterativa) ===")
    print(f"Caminho da solução: {' -> '.join(path_to_go_dfs)}")
    print(f"Custo da solução: {cost_of_path_dfs}")
    print(f"Nós expandidos: {nodes_expanded_dfs}")
    print(f"Profundidade máxima da busca: {max_depth_dfs}")
    print(f"Tempo de execução: {tempo_dfs:.6f} segundos")
    print(f"Uso de memória: {memoria_dfs:.2f} MB")
else:
    print("\nNenhuma solução encontrada utilizando DFS.")

if solucao_ids:
    path_to_go_ids = imprimir_caminho(solucao_ids)
    cost_of_path_ids = solucao_ids.custo

    print("\n=== Solução por IDS (Busca Iterativa em Profundidade) ===")
    print(f"Caminho da solução: {' -> '.join(path_to_go_ids)}")
    print(f"Custo da solução: {cost_of_path_ids}")
    print(f"Profundidade da solução: {profundidade_ids}")
    print(f"Tempo de execução: {tempo_ids:.6f} segundos")
    print(f"Uso de memória: {memoria_ids:.2f} MB")
else:
    print("\nNenhuma solução encontrada utilizando IDS.")

"""Classe do nó, que define como será a estrutura da árvore, assim como os movimentos e direções.

O objetivo final é como o tabuleiro será organizado.

A classe `Node` representa um nó da árvore de busca e armazena todas as informações necessárias para rastrear o caminho até o objetivo:

- `estado`: o estado atual do tabuleiro (matriz 3x3).
- `pai`: referência para o nó anterior, permitindo a reconstrução do caminho após encontrar a solução.
- `acao`: direção do movimento realizado para chegar ao estado atual (ex: "cima", "baixo").
- `custo`: custo acumulado para chegar a este nó (no caso do 8-puzzle, cada movimento tem custo 1).
"""

class Node:
    def __init__(self, estado, pai=None, acao="", custo=0):
        self.estado = estado
        self.pai = pai
        self.acao = acao
        self.custo = custo

# Direções e movimentos possíveis
movimentos = [(-1, 0), (1, 0), (0, -1), (0, 1)]
direcao = ["cima", "baixo", "esquerda", "direita"]

# Estado objetivo final
objetivo_final = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

"""# Objetivo.

A função objetivo verifica se se o estado atual do tabuleiro é igual ao estado final, que é definido no início do código.
"""

def chegou_objetivo(estado):
    return estado == objetivo_final

"""# Encontrar zero

A função encontrar zero percorre o tabuleiro para encontrar a posição do zero, retornando os inddices da matriz, e com isso poer mover as peças para que se possa resolver o quebra cabeça.
"""

def encontrar_zero(estado):
    for i in range(3):
        for j in range(3):
            if estado[i][j] == 0:
                return i, j
    return -1, -1

"""# Expandir os nós.

A função expandir, gera todos os filhos o nó atual que podderam ser visitados e que permite a movimentação pelo tabuleiro, que depende da posição do zero na atual iteração
"""

def expandir(node):
    filhos = []
    x, y = encontrar_zero(node.estado)

    for i in range(4):
        nx, ny = x + movimentos[i][0], y + movimentos[i][1]
        if 0 <= nx < 3 and 0 <= ny < 3:
            novo_estado = [linha[:] for linha in node.estado]  # Copia a matriz
            novo_estado[x][y], novo_estado[nx][ny] = novo_estado[nx][ny], novo_estado[x][y]
            filhos.append(Node(novo_estado, node, direcao[i], node.custo + 1))
    return filhos

"""# BFS

Implementação padrão de uma BFS, que percorre a árvore em largura, indo de níveis em níveis pela árvore, usa uma fila e guarda os nós que já foram visitados. A mesma retorna Número de nós expandidos, tamanho atual e máximo da fronteira, profundidade da solução, tempo de execução e uso de memória.

Garante encontrar a solução com o menor número de movimentos, mas pode consumir muita memória em problemas mais complexos.
"""

def bfs(root):
    inicio_tempo = time.time()

    fronteira = deque([root])
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        node = fronteira.popleft()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                fronteira.append(filho)

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

"""DFS
Executa a Busca em Profundidade, aqui utilizamos um pilha, para evitar um gasto muito excessivo de memória e vitar os loops infinitos, expadne os nós antes de retroceder, impõe um limite de profundidade para também evitar loops infinitos.Armazena os estados visitados para evitar ciclos.

Retorna os seguitnes os:
Solução encontrada (ou None), nós expandidos, profundidade máxima atingida,tempo de execução e o uso de memória.

DFS consome menos memória que BFS, mas pode não encontrar a solução ótima e pode se perder em caminhos profundos sem saída.
"""

def dfs(root, limite=100):
    inicio = time.time()
    pilha = [root]
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    max_search_depth = 0

    while pilha:
        node = pilha.pop()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo = time.time() - inicio
            memoria = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, max_search_depth, tempo, memoria

        if node.custo < limite:
            filhos = expandir(node)
            for filho in reversed(filhos):
                filho_estado = tuple(map(tuple, filho.estado))
                if filho_estado not in visitado:
                    visitado.add(filho_estado)
                    pilha.append(filho)
                    max_search_depth = max(max_search_depth, filho.custo)

    tempo = time.time() - inicio
    memoria = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, max_search_depth, tempo, memoria

"""IDS
Aqui temos uas funções a principal a IDS que é a busca de forma interativa e a dls que auxilia a ids.
A dls chama a função dfs() com um limite de profundidade específico, retorna a solução se for encontrada dentro desse limite caso contrário, retorna "Fora".

Já a ids executa a Busca em Profundidade Iterativa (Iterative Deepening Search), combinando as vantagens da BFS e da DFS.

Repete a DFS com limites de profundidade crescentes (0, 1, 2, ..., N), Garante encontrar a solução mais curta como na BFS.
Utiliza menos memória, como a DFS.

Mede e retorna os seguintes dados:

Nó solução, profundidade da solução, tempo de execução, uso de memória.

Esse método é eficaz para espaços de estados grandes e profundos, onde a BFS não é viável.
"""

def dls(root, limite):
    return dfs(root, limite)[0]  # Retorna apenas o node

def ids(root):
    inicio = time.time()
    profundidade_maxima = 100
    memoria = 0
    for limite in range(profundidade_maxima):
        resultado = dls(root, limite)
        memoria = psutil.Process().memory_info().rss / (1024 * 1024)
        if resultado:
            tempo = time.time() - inicio
            return resultado, limite, tempo, memoria
    return None, profundidade_maxima, time.time() - inicio, memoria

"""# Imprimir o caminho

Reconstrói o caminho de ações desde a raiz até o nó final.
Se utiliza o atributo pai de cada nó para voltar até a origem e armazena a sequência de direções em uma lista, que é então invertida para mostrar o caminho do início até o objetivo.
"""

def imprimir_caminho(node):
    if node is None:
        return []
    caminho = []
    while node.pai is not None:
        caminho.append(node.acao)
        node = node.pai
    caminho.reverse()
    return caminho

"""# A estrutura o código de busca em si foi mantido, sendo eitas apenas as alterações tanto para a estratégia gulosa quanto para o A*
# Abaixo estão adicionados os algoritmos utilizando a forma gulosa e o A*, junto também com a heuristica ded Manhattan

Heuristica de Manhattan
"""

def heuristica_Manhattan(estado):
  distancia = 0
  for i in range(3):
    for j in range(3):
      valor = estado[i][j]
      if valor != 0:
        linha_obj, col_obj = divmod(valor -1, 3)
        distancia += abs(i - linha_obj) + abs(j - col_obj)
  return distancia

def h(no):
    return heuristica_Manhattan(no.estado)

"""# Busca gulosa"""

def bfs_gulosa(root):
    inicio_tempo = time.time()

    fronteira = []
    contador = count()
    heapq.heappush(fronteira, (h(root), next(contador), root))

    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                heapq.heappush(fronteira, (h(filho), next(contador), filho))

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)


    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

"""# A*"""

def BFS_Aestrela(root):
    inicio_tempo = time.time()
    contador = count()

    fronteira = []
    heapq.heappush(fronteira, (root.custo + h(root), next(contador), root))


    visitado = {}
    visitado[tuple(map(tuple, root.estado))] = root.custo

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado or filho.custo < visitado[filho_tupla]:
              visitado[filho_tupla] = filho.custo
              heapq.heappush(fronteira, (filho.custo + h(filho), next(contador), filho))


              fringe_size = len(fronteira)
              max_fringe_size = max(max_fringe_size, fringe_size)
              search_depth = filho.custo
              max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

"""# Abaixo temos a implentação com ambos os algorítmos"""

import heapq
from itertools import count
import time
import psutil
from collections import deque

class Node:
    def __init__(self, estado, pai=None, acao="", custo=0):
        self.estado = estado
        self.pai = pai
        self.acao = acao
        self.custo = custo


movimentos = [(-1, 0), (1, 0), (0, -1), (0, 1)]
direcao = ["cima", "baixo", "esquerda", "direita"]


objetivo_final = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

def chegou_objetivo(estado):
    return estado == objetivo_final

def encontrar_zero(estado):
    for i in range(3):
        for j in range(3):
            if estado[i][j] == 0:
                return i, j
    return -1, -1

def expandir(node):
    filhos = []
    x, y = encontrar_zero(node.estado)

    for i in range(4):
        nx, ny = x + movimentos[i][0], y + movimentos[i][1]
        if 0 <= nx < 3 and 0 <= ny < 3:
            novo_estado = [linha[:] for linha in node.estado]  # Copia a matriz
            novo_estado[x][y], novo_estado[nx][ny] = novo_estado[nx][ny], novo_estado[x][y]
            filhos.append(Node(novo_estado, node, direcao[i], node.custo + 1))
    return filhos



def bfs_gulosa(root):
    inicio_tempo = time.time()

    fronteira = []
    contador = count()
    heapq.heappush(fronteira, (h(root), next(contador), root))

    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                heapq.heappush(fronteira, (h(filho), next(contador), filho))

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)


    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso


def heuristica_Manhattan(estado):
  distancia = 0
  for i in range(3):
    for j in range(3):
      valor = estado[i][j]
      if valor != 0:
        linha_obj, col_obj = divmod(valor -1, 3)
        distancia += abs(i - linha_obj) + abs(j - col_obj)
  return distancia

def h(no):
    return heuristica_Manhattan(no.estado)



#A estrela


def BFS_Aestrela(root):
    inicio_tempo = time.time()
    contador = count()

    fronteira = []
    heapq.heappush(fronteira, (root.custo + h(root), next(contador), root))


    visitado = {}
    visitado[tuple(map(tuple, root.estado))] = root.custo

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado or filho.custo < visitado[filho_tupla]:
              visitado[filho_tupla] = filho.custo
              heapq.heappush(fronteira, (filho.custo + h(filho), next(contador), filho))


              fringe_size = len(fronteira)
              max_fringe_size = max(max_fringe_size, fringe_size)
              search_depth = filho.custo
              max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

def imprimir_caminho(node):
    if node is None:
        return []
    caminho = []
    while node.pai is not None:
        caminho.append(node.acao)
        node = node.pai
    caminho.reverse()
    return caminho


# Tabuleiro de entrada
tabuleiro = [
    [8, 2, 1],
    [4, 0, 6],
    [5, 3, 7]
]

# [8, 7, 6, 5, 4, 3, 2, 1, 0]
# [0, 5, 1, 6, 4, 3, 8, 2, 7]
# [7, 4, 0, 1, 2, 5, 6, 8, 3]
# [1, 3, 6, 5, 0, 2, 4, 7, 8]

raiz = Node(tabuleiro)


solucao, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso = bfs_gulosa(raiz)
solucao_astar, nodes_expanded_astar, fringe_size_astar, max_fringe_size_astar, search_depth_astar, max_search_depth_astar, tempo_decorrido_astar, memoria_uso_astar = BFS_Aestrela(raiz)

if solucao:
    path_to_go_bfs = imprimir_caminho(solucao)
    cost_of_path_bfs = solucao.custo

    print("\n=== Solução por BFS Gulosa ===")
    print(f"Caminho da solução: {' -> '.join(path_to_go_bfs)}")
    print(f"Custo da solução: {cost_of_path_bfs}")
    print(f"Nós expandidos: {nodes_expanded}")
    print(f"Tamanho da fronteira: {fringe_size}")
    print(f"Tamanho máximo da fronteira: {max_fringe_size}")
    print(f"Profundidade da busca: {search_depth}")
    print(f"Profundidade máxima da busca: {max_search_depth}")
    print(f"Tempo de execução: {tempo_decorrido:.6f} segundos")
    print(f"Uso de memória: {memoria_uso:.2f} MB")
else:
    print("Nenhuma solução encontrada utilizando BFS Gulosa.")



if solucao_astar:
    path_to_go_a_star = imprimir_caminho(solucao_astar)
    cost_of_path_a_star = solucao_astar.custo

    print("\n=== Solução por A* ===")
    print(f"Caminho da solução: {' -> '.join(path_to_go_a_star)}")
    print(f"Custo da solução: {cost_of_path_a_star}")
    print(f"Nós expandidos: {nodes_expanded_astar}")
    print(f"Tamanho da fronteira: {fringe_size_astar}")
    print(f"Tamanho máximo da fronteira: {max_fringe_size_astar}")
    print(f"Profundidade da busca: {search_depth_astar}")
    print(f"Profundidade máxima da busca: {max_search_depth_astar}")
    print(f"Tempo de execução: {tempo_decorrido_astar:.6f} segundos")
    print(f"Uso de memória: {memoria_uso_astar:.2f} MB")