# -*- coding: utf-8 -*-
"""Eight_puzzle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g6z5Dy_2QLpTrIzWqCyZoIaz1e4UQ3hn

# Pedro Vitor de Souza Dantas
# Solucionador do 8-Puzzle com Agentes Guiados a Objetivo

## Introdu√ß√£o

Este projeto apresenta a implementa√ß√£o de tr√™s agentes para resolver o problema do 8-puzzle, utilizando algoritmos cl√°ssicos de busca:

As celulas est√£o organizadas da seguinte forma, a primeiira est√° o c√≥digo completo que ser√° executado, em seguida as fun√ß√µes est√£o separadas para uma melhor explica√ß√£o das mesmas.

- **Busca em Largura (BFS - Breadth-First Search)**
- **Busca em Profundidade (DFS - Depth-First Search)**
- **Busca por Aprofundamento Iterativo (IDS - Iterative Deepening Search)**
- **Busca gulosa**
- **Busca utilizando o A**

Cada movimento tem custo unit√°rio e as a√ß√µes geradas pela fun√ß√£o sucessora sempre resultam em estados v√°lidos. O objetivo do agente √© transformar um estado inicial em um estado objetivo atrav√©s de uma sequ√™ncia m√≠nima de movimentos.

As buscas s√£o avaliadas em termos de:
- Custo da solu√ß√£o
- N√≥s expandidos
- Profundidade da solu√ß√£o
- Tempo de execu√ß√£o
- Uso de mem√≥ria

---
# O c√≥digo a seguir segue tal estrutura:
### Imports, classe Node, fun√ß√µes de movimenta√ß√£o e expans√£o
### Implementa√ß√£o de BFS, DFS e IDS, Guloso, A*
### Tabuleiro de teste
### Execu√ß√£o dos algoritmos

## Explica√ß√£o do Funcionamento

- **Classe Node**: representa cada estado do tabuleiro. Guarda o estado, o n√≥ pai (para reconstru√ß√£o do caminho), a a√ß√£o realizada e o custo.
- **Fun√ß√µes auxiliares**:
  - `chegou_objetivo`: verifica se o estado atual √© o estado final.
  - `expandir`: gera os poss√≠veis filhos de um n√≥ movendo o espa√ßo vazio (0).
- **BFS**: percorre os estados em largura, garantindo a menor solu√ß√£o poss√≠vel. Pode consumir muita mem√≥ria.
- **DFS**: busca em profundidade recursiva com limite. Menor uso de mem√≥ria, mas pode n√£o encontrar a solu√ß√£o.
- **IDS**: executa DFS com limites crescentes. Encontra solu√ß√µes √≥timas com menor uso de mem√≥ria que BFS.

---

# O resultado final o tabuleiro √©:


### Estado final:
```
[1, 2, 3]
[4, 5, 6]
[7, 8, 0]

```
# A seguir temos os casos de testes:
##[1, 3, 6, 5, 0, 2, 4, 7, 8]

=== Solu√ß√£o por BFS ===
Caminho da solu√ß√£o: direita -> cima -> esquerda -> baixo -> esquerda -> baixo -> direita -> direita
Custo da solu√ß√£o: 8
N√≥s expandidos: 311
Tamanho da fronteira: 190
Tamanho m√°ximo da fronteira: 190
Profundidade da busca: 9
Profundidade m√°xima da busca: 9
Tempo de execu√ß√£o: 0.021288 segundos
Uso de mem√≥ria: 100.34 MB

=== Solu√ß√£o por DFS (com pilha iterativa) ===
Caminho da solu√ß√£o: cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> cima -> direita -> direita -> baixo -> baixo -> esquerda -> cima -> esquerda -> cima -> direita -> baixo -> direita -> baixo
Custo da solu√ß√£o: 100
N√≥s expandidos: 100368
Profundidade m√°xima da busca: 100
Tempo de execu√ß√£o: 2.034564 segundos
Uso de mem√≥ria: 128.75 MB

=== Solu√ß√£o por IDS (Busca Iterativa em Profundidade) ===
Caminho da solu√ß√£o: cima -> direita -> baixo -> esquerda -> cima -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita
Custo da solu√ß√£o: 12
Profundidade da solu√ß√£o: 12
Tempo de execu√ß√£o: 0.063092 segundos

---------------------------------------------------------------------------------------------------

##[7, 4, 0, 1, 2, 5, 6, 8, 3]

=== Solu√ß√£o por BFS ===
Caminho da solu√ß√£o: baixo -> esquerda -> esquerda -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo
Custo da solu√ß√£o: 20
N√≥s expandidos: 45629
Tamanho da fronteira: 17228
Tamanho m√°ximo da fronteira: 17289
Profundidade da busca: 21
Profundidade m√°xima da busca: 21
Tempo de execu√ß√£o: 1.332135 segundos
Uso de mem√≥ria: 143.27 MB

=== Solu√ß√£o por DFS (com pilha iterativa) ===
Caminho da solu√ß√£o: baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> direita -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> direita -> cima -> esquerda -> baixo -> direita -> direita -> baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> baixo -> direita
Custo da solu√ß√£o: 98
N√≥s expandidos: 44281
Profundidade m√°xima da busca: 100
Tempo de execu√ß√£o: 0.338363 segundos
Uso de mem√≥ria: 143.27 MB

=== Solu√ß√£o por IDS (Busca Iterativa em Profundidade) ===
Caminho da solu√ß√£o: baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> baixo -> direita
Custo da solu√ß√£o: 26
Profundidade da solu√ß√£o: 26
Tempo de execu√ß√£o: 0.518088 segundos
Uso de mem√≥ria: 138.58 MB


##[0, 5, 1, 6, 4, 3, 8, 2, 7]


=== Solu√ß√£o por BFS ===
Caminho da solu√ß√£o: baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> cima -> direita -> baixo -> esquerda -> baixo -> direita -> direita
Custo da solu√ß√£o: 24
N√≥s expandidos: 119087
Tamanho da fronteira: 23308
Tamanho m√°ximo da fronteira: 24048
Profundidade da busca: 25
Profundidade m√°xima da busca: 25
Tempo de execu√ß√£o: 3.193469 segundos
Uso de mem√≥ria: 186.79 MB

=== Solu√ß√£o por DFS (com pilha iterativa) ===
Caminho da solu√ß√£o: baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> baixo -> baixo -> direita -> cima -> esquerda -> cima -> direita -> baixo -> direita -> cima -> esquerda -> esquerda -> baixo -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> baixo -> direita
Custo da solu√ß√£o: 100
N√≥s expandidos: 53588
Profundidade m√°xima da busca: 100
Tempo de execu√ß√£o: 0.225635 segundos
Uso de mem√≥ria: 186.79 MB

=== Solu√ß√£o por IDS (Busca Iterativa em Profundidade) ===
Caminho da solu√ß√£o: baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> esquerda -> esquerda -> cima -> direita -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> cima -> esquerda -> baixo -> direita -> baixo
Custo da solu√ß√£o: 30
Profundidade da solu√ß√£o: 30
Tempo de execu√ß√£o: 1.159473 segundos
Uso de mem√≥ria: 157.77 MB

##[8, 7, 6, 5, 4, 3, 2, 1, 0]


=== Solu√ß√£o por BFS ===
Caminho da solu√ß√£o: cima -> esquerda -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> baixo -> direita
Custo da solu√ß√£o: 30
N√≥s expandidos: 181393
Tamanho da fronteira: 150
Tamanho m√°ximo da fronteira: 24054
Profundidade da busca: 31
Profundidade m√°xima da busca: 31
Tempo de execu√ß√£o: 4.328634 segundos
Uso de mem√≥ria: 196.95 MB

=== Solu√ß√£o por DFS (com pilha iterativa) ===
Caminho da solu√ß√£o: cima -> cima -> esquerda -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> direita -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> direita -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> esquerda -> baixo -> direita -> direita -> cima -> cima -> esquerda -> esquerda -> baixo -> direita -> direita -> baixo
Custo da solu√ß√£o: 100
N√≥s expandidos: 6979
Profundidade m√°xima da busca: 100
Tempo de execu√ß√£o: 0.029800 segundos
Uso de mem√≥ria: 188.61 MB

=== Solu√ß√£o por IDS (Busca Iterativa em Profundidade) ===
Caminho da solu√ß√£o: cima -> esquerda -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> esquerda -> baixo -> baixo -> direita -> cima -> cima -> direita -> baixo -> baixo -> esquerda -> cima -> cima -> direita -> baixo -> esquerda -> cima -> esquerda -> baixo -> direita -> baixo -> direita
Custo da solu√ß√£o: 30
Profundidade da solu√ß√£o: 33
Tempo de execu√ß√£o: 2.203781 segundos
Uso de mem√≥ria: 171.76 MB


---

### üìå **Conclus√£o**

```markdown
## Conclus√£o

Com base nos experimentos realizados, √© poss√≠vel concluir que:

- **Busca em Largura (BFS)** encontra sempre a solu√ß√£o √≥tima, mas pode consumir muita mem√≥ria em estados mais profundos.
- **Busca em Profundidade (DFS)** √© mais leve em mem√≥ria, por√©m pode n√£o encontrar a solu√ß√£o ideal ou mesmo nenhuma, dependendo do limite.
- **Busca por Aprofundamento Iterativo (IDS)** combina o melhor dos dois mundos: encontra solu√ß√µes √≥timas com menor uso de mem√≥ria, apesar de realizar buscas repetidas.

### ‚úÖ Melhor algoritmo: **IDS**
- Encontrou a solu√ß√£o √≥tima
- Usou mem√≥ria moderada
- Balanceou profundidade e tempo

### ‚ùå Pior algoritmo: **DFS**
- Apesar de r√°pido e leve, pode falhar em encontrar solu√ß√µes, especialmente com limites mal definidos.

---
"""

import time
import psutil  # Biblioteca para medir uso de mem√≥ria
from collections import deque

class Node:
    def __init__(self, estado, pai=None, acao="", custo=0):
        self.estado = estado
        self.pai = pai
        self.acao = acao
        self.custo = custo

# Dire√ß√µes e movimentos poss√≠veis
movimentos = [(-1, 0), (1, 0), (0, -1), (0, 1)]
direcao = ["cima", "baixo", "esquerda", "direita"]

# Estado objetivo final
objetivo_final = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

def chegou_objetivo(estado):
    return estado == objetivo_final

def encontrar_zero(estado):
    for i in range(3):
        for j in range(3):
            if estado[i][j] == 0:
                return i, j
    return -1, -1

def expandir(node):
    filhos = []
    x, y = encontrar_zero(node.estado)

    for i in range(4):
        nx, ny = x + movimentos[i][0], y + movimentos[i][1]
        if 0 <= nx < 3 and 0 <= ny < 3:
            novo_estado = [linha[:] for linha in node.estado]  # Copia a matriz
            novo_estado[x][y], novo_estado[nx][ny] = novo_estado[nx][ny], novo_estado[x][y]
            filhos.append(Node(novo_estado, node, direcao[i], node.custo + 1))
    return filhos

def bfs(root):
    inicio_tempo = time.time()

    fronteira = deque([root])
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        node = fronteira.popleft()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                fronteira.append(filho)

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

def imprimir_caminho(node):
    if node is None:
        return []
    caminho = []
    while node.pai is not None:
        caminho.append(node.acao)
        node = node.pai
    caminho.reverse()
    return caminho

# DFS com pilha (iterativa)
def dfs(root, limite=100):
    inicio = time.time()
    pilha = [root]
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    max_search_depth = 0

    while pilha:
        node = pilha.pop()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo = time.time() - inicio
            memoria = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, max_search_depth, tempo, memoria

        if node.custo < limite:
            filhos = expandir(node)
            for filho in reversed(filhos):
                filho_estado = tuple(map(tuple, filho.estado))
                if filho_estado not in visitado:
                    visitado.add(filho_estado)
                    pilha.append(filho)
                    max_search_depth = max(max_search_depth, filho.custo)

    tempo = time.time() - inicio
    memoria = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, max_search_depth, tempo, memoria

# IDS com DFS limitada
def dls(root, limite):
    return dfs(root, limite)[0]  # Retorna apenas o node

def ids(root):
    inicio = time.time()
    profundidade_maxima = 100
    memoria = 0
    for limite in range(profundidade_maxima):
        resultado = dls(root, limite)
        memoria = psutil.Process().memory_info().rss / (1024 * 1024)
        if resultado:
            tempo = time.time() - inicio
            return resultado, limite, tempo, memoria
    return None, profundidade_maxima, time.time() - inicio, memoria

# Tabuleiro de entrada
tabuleiro = [
    [8, 7, 6],
    [5, 4, 3],
    [2, 1, 0]
]


raiz = Node(tabuleiro)

# Execu√ß√£o da BFS
solucao, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso = bfs(raiz)

# Execu√ß√£o da DFS
solucao_dfs, nodes_expanded_dfs, max_depth_dfs, tempo_dfs, memoria_dfs = dfs(raiz)

# Execu√ß√£o da IDS
solucao_ids, profundidade_ids, tempo_ids, memoria_ids = ids(raiz)

# Impress√£o dos resultados
if solucao:
    path_to_go_bfs = imprimir_caminho(solucao)
    cost_of_path_bfs = solucao.custo

    print("\n=== Solu√ß√£o por BFS ===")
    print(f"Caminho da solu√ß√£o: {' -> '.join(path_to_go_bfs)}")
    print(f"Custo da solu√ß√£o: {cost_of_path_bfs}")
    print(f"N√≥s expandidos: {nodes_expanded}")
    print(f"Tamanho da fronteira: {fringe_size}")
    print(f"Tamanho m√°ximo da fronteira: {max_fringe_size}")
    print(f"Profundidade da busca: {search_depth}")
    print(f"Profundidade m√°xima da busca: {max_search_depth}")
    print(f"Tempo de execu√ß√£o: {tempo_decorrido:.6f} segundos")
    print(f"Uso de mem√≥ria: {memoria_uso:.2f} MB")
else:
    print("Nenhuma solu√ß√£o encontrada utilizando BFS.")

if solucao_dfs:
    path_to_go_dfs = imprimir_caminho(solucao_dfs)
    cost_of_path_dfs = solucao_dfs.custo

    print("\n=== Solu√ß√£o por DFS (com pilha iterativa) ===")
    print(f"Caminho da solu√ß√£o: {' -> '.join(path_to_go_dfs)}")
    print(f"Custo da solu√ß√£o: {cost_of_path_dfs}")
    print(f"N√≥s expandidos: {nodes_expanded_dfs}")
    print(f"Profundidade m√°xima da busca: {max_depth_dfs}")
    print(f"Tempo de execu√ß√£o: {tempo_dfs:.6f} segundos")
    print(f"Uso de mem√≥ria: {memoria_dfs:.2f} MB")
else:
    print("\nNenhuma solu√ß√£o encontrada utilizando DFS.")

if solucao_ids:
    path_to_go_ids = imprimir_caminho(solucao_ids)
    cost_of_path_ids = solucao_ids.custo

    print("\n=== Solu√ß√£o por IDS (Busca Iterativa em Profundidade) ===")
    print(f"Caminho da solu√ß√£o: {' -> '.join(path_to_go_ids)}")
    print(f"Custo da solu√ß√£o: {cost_of_path_ids}")
    print(f"Profundidade da solu√ß√£o: {profundidade_ids}")
    print(f"Tempo de execu√ß√£o: {tempo_ids:.6f} segundos")
    print(f"Uso de mem√≥ria: {memoria_ids:.2f} MB")
else:
    print("\nNenhuma solu√ß√£o encontrada utilizando IDS.")

"""Classe do n√≥, que define como ser√° a estrutura da √°rvore, assim como os movimentos e dire√ß√µes.

O objetivo final √© como o tabuleiro ser√° organizado.

A classe `Node` representa um n√≥ da √°rvore de busca e armazena todas as informa√ß√µes necess√°rias para rastrear o caminho at√© o objetivo:

- `estado`: o estado atual do tabuleiro (matriz 3x3).
- `pai`: refer√™ncia para o n√≥ anterior, permitindo a reconstru√ß√£o do caminho ap√≥s encontrar a solu√ß√£o.
- `acao`: dire√ß√£o do movimento realizado para chegar ao estado atual (ex: "cima", "baixo").
- `custo`: custo acumulado para chegar a este n√≥ (no caso do 8-puzzle, cada movimento tem custo 1).
"""

class Node:
    def __init__(self, estado, pai=None, acao="", custo=0):
        self.estado = estado
        self.pai = pai
        self.acao = acao
        self.custo = custo

# Dire√ß√µes e movimentos poss√≠veis
movimentos = [(-1, 0), (1, 0), (0, -1), (0, 1)]
direcao = ["cima", "baixo", "esquerda", "direita"]

# Estado objetivo final
objetivo_final = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

"""# Objetivo.

A fun√ß√£o objetivo verifica se se o estado atual do tabuleiro √© igual ao estado final, que √© definido no in√≠cio do c√≥digo.
"""

def chegou_objetivo(estado):
    return estado == objetivo_final

"""# Encontrar zero

A fun√ß√£o encontrar zero percorre o tabuleiro para encontrar a posi√ß√£o do zero, retornando os inddices da matriz, e com isso poer mover as pe√ßas para que se possa resolver o quebra cabe√ßa.
"""

def encontrar_zero(estado):
    for i in range(3):
        for j in range(3):
            if estado[i][j] == 0:
                return i, j
    return -1, -1

"""# Expandir os n√≥s.

A fun√ß√£o expandir, gera todos os filhos o n√≥ atual que podderam ser visitados e que permite a movimenta√ß√£o pelo tabuleiro, que depende da posi√ß√£o do zero na atual itera√ß√£o
"""

def expandir(node):
    filhos = []
    x, y = encontrar_zero(node.estado)

    for i in range(4):
        nx, ny = x + movimentos[i][0], y + movimentos[i][1]
        if 0 <= nx < 3 and 0 <= ny < 3:
            novo_estado = [linha[:] for linha in node.estado]  # Copia a matriz
            novo_estado[x][y], novo_estado[nx][ny] = novo_estado[nx][ny], novo_estado[x][y]
            filhos.append(Node(novo_estado, node, direcao[i], node.custo + 1))
    return filhos

"""# BFS

Implementa√ß√£o padr√£o de uma BFS, que percorre a √°rvore em largura, indo de n√≠veis em n√≠veis pela √°rvore, usa uma fila e guarda os n√≥s que j√° foram visitados. A mesma retorna N√∫mero de n√≥s expandidos, tamanho atual e m√°ximo da fronteira, profundidade da solu√ß√£o, tempo de execu√ß√£o e uso de mem√≥ria.

Garante encontrar a solu√ß√£o com o menor n√∫mero de movimentos, mas pode consumir muita mem√≥ria em problemas mais complexos.
"""

def bfs(root):
    inicio_tempo = time.time()

    fronteira = deque([root])
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        node = fronteira.popleft()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                fronteira.append(filho)

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

"""DFS
Executa a Busca em Profundidade, aqui utilizamos um pilha, para evitar um gasto muito excessivo de mem√≥ria e vitar os loops infinitos, expadne os n√≥s antes de retroceder, imp√µe um limite de profundidade para tamb√©m evitar loops infinitos.Armazena os estados visitados para evitar ciclos.

Retorna os seguitnes os:
Solu√ß√£o encontrada (ou None), n√≥s expandidos, profundidade m√°xima atingida,tempo de execu√ß√£o e o uso de mem√≥ria.

DFS consome menos mem√≥ria que BFS, mas pode n√£o encontrar a solu√ß√£o √≥tima e pode se perder em caminhos profundos sem sa√≠da.
"""

def dfs(root, limite=100):
    inicio = time.time()
    pilha = [root]
    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    max_search_depth = 0

    while pilha:
        node = pilha.pop()
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo = time.time() - inicio
            memoria = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, max_search_depth, tempo, memoria

        if node.custo < limite:
            filhos = expandir(node)
            for filho in reversed(filhos):
                filho_estado = tuple(map(tuple, filho.estado))
                if filho_estado not in visitado:
                    visitado.add(filho_estado)
                    pilha.append(filho)
                    max_search_depth = max(max_search_depth, filho.custo)

    tempo = time.time() - inicio
    memoria = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, max_search_depth, tempo, memoria

"""IDS
Aqui temos uas fun√ß√µes a principal a IDS que √© a busca de forma interativa e a dls que auxilia a ids.
A dls chama a fun√ß√£o dfs() com um limite de profundidade espec√≠fico, retorna a solu√ß√£o se for encontrada dentro desse limite caso contr√°rio, retorna "Fora".

J√° a ids executa a Busca em Profundidade Iterativa (Iterative Deepening Search), combinando as vantagens da BFS e da DFS.

Repete a DFS com limites de profundidade crescentes (0, 1, 2, ..., N), Garante encontrar a solu√ß√£o mais curta como na BFS.
Utiliza menos mem√≥ria, como a DFS.

Mede e retorna os seguintes dados:

N√≥ solu√ß√£o, profundidade da solu√ß√£o, tempo de execu√ß√£o, uso de mem√≥ria.

Esse m√©todo √© eficaz para espa√ßos de estados grandes e profundos, onde a BFS n√£o √© vi√°vel.
"""

def dls(root, limite):
    return dfs(root, limite)[0]  # Retorna apenas o node

def ids(root):
    inicio = time.time()
    profundidade_maxima = 100
    memoria = 0
    for limite in range(profundidade_maxima):
        resultado = dls(root, limite)
        memoria = psutil.Process().memory_info().rss / (1024 * 1024)
        if resultado:
            tempo = time.time() - inicio
            return resultado, limite, tempo, memoria
    return None, profundidade_maxima, time.time() - inicio, memoria

"""# Imprimir o caminho

Reconstr√≥i o caminho de a√ß√µes desde a raiz at√© o n√≥ final.
Se utiliza o atributo pai de cada n√≥ para voltar at√© a origem e armazena a sequ√™ncia de dire√ß√µes em uma lista, que √© ent√£o invertida para mostrar o caminho do in√≠cio at√© o objetivo.
"""

def imprimir_caminho(node):
    if node is None:
        return []
    caminho = []
    while node.pai is not None:
        caminho.append(node.acao)
        node = node.pai
    caminho.reverse()
    return caminho

"""# A estrutura o c√≥digo de busca em si foi mantido, sendo eitas apenas as altera√ß√µes tanto para a estrat√©gia gulosa quanto para o A*
# Abaixo est√£o adicionados os algoritmos utilizando a forma gulosa e o A*, junto tamb√©m com a heuristica ded Manhattan

Heuristica de Manhattan
"""

def heuristica_Manhattan(estado):
  distancia = 0
  for i in range(3):
    for j in range(3):
      valor = estado[i][j]
      if valor != 0:
        linha_obj, col_obj = divmod(valor -1, 3)
        distancia += abs(i - linha_obj) + abs(j - col_obj)
  return distancia

def h(no):
    return heuristica_Manhattan(no.estado)

"""# Busca gulosa"""

def bfs_gulosa(root):
    inicio_tempo = time.time()

    fronteira = []
    contador = count()
    heapq.heappush(fronteira, (h(root), next(contador), root))

    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                heapq.heappush(fronteira, (h(filho), next(contador), filho))

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)


    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

"""# A*"""

def BFS_Aestrela(root):
    inicio_tempo = time.time()
    contador = count()

    fronteira = []
    heapq.heappush(fronteira, (root.custo + h(root), next(contador), root))


    visitado = {}
    visitado[tuple(map(tuple, root.estado))] = root.custo

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado or filho.custo < visitado[filho_tupla]:
              visitado[filho_tupla] = filho.custo
              heapq.heappush(fronteira, (filho.custo + h(filho), next(contador), filho))


              fringe_size = len(fronteira)
              max_fringe_size = max(max_fringe_size, fringe_size)
              search_depth = filho.custo
              max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

"""# Abaixo temos a implenta√ß√£o com ambos os algor√≠tmos"""

import heapq
from itertools import count
import time
import psutil
from collections import deque

class Node:
    def __init__(self, estado, pai=None, acao="", custo=0):
        self.estado = estado
        self.pai = pai
        self.acao = acao
        self.custo = custo


movimentos = [(-1, 0), (1, 0), (0, -1), (0, 1)]
direcao = ["cima", "baixo", "esquerda", "direita"]


objetivo_final = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

def chegou_objetivo(estado):
    return estado == objetivo_final

def encontrar_zero(estado):
    for i in range(3):
        for j in range(3):
            if estado[i][j] == 0:
                return i, j
    return -1, -1

def expandir(node):
    filhos = []
    x, y = encontrar_zero(node.estado)

    for i in range(4):
        nx, ny = x + movimentos[i][0], y + movimentos[i][1]
        if 0 <= nx < 3 and 0 <= ny < 3:
            novo_estado = [linha[:] for linha in node.estado]  # Copia a matriz
            novo_estado[x][y], novo_estado[nx][ny] = novo_estado[nx][ny], novo_estado[x][y]
            filhos.append(Node(novo_estado, node, direcao[i], node.custo + 1))
    return filhos



def bfs_gulosa(root):
    inicio_tempo = time.time()

    fronteira = []
    contador = count()
    heapq.heappush(fronteira, (h(root), next(contador), root))

    visitado = set()
    visitado.add(tuple(map(tuple, root.estado)))

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado:
                visitado.add(filho_tupla)
                heapq.heappush(fronteira, (h(filho), next(contador), filho))

                fringe_size = len(fronteira)
                max_fringe_size = max(max_fringe_size, fringe_size)
                search_depth = filho.custo
                max_search_depth = max(max_search_depth, search_depth)


    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso


def heuristica_Manhattan(estado):
  distancia = 0
  for i in range(3):
    for j in range(3):
      valor = estado[i][j]
      if valor != 0:
        linha_obj, col_obj = divmod(valor -1, 3)
        distancia += abs(i - linha_obj) + abs(j - col_obj)
  return distancia

def h(no):
    return heuristica_Manhattan(no.estado)



#A estrela


def BFS_Aestrela(root):
    inicio_tempo = time.time()
    contador = count()

    fronteira = []
    heapq.heappush(fronteira, (root.custo + h(root), next(contador), root))


    visitado = {}
    visitado[tuple(map(tuple, root.estado))] = root.custo

    nodes_expanded = 0
    fringe_size = 1
    max_fringe_size = 1
    search_depth = 0
    max_search_depth = 0

    while fronteira:
        _, _, node = heapq.heappop(fronteira)
        nodes_expanded += 1

        if chegou_objetivo(node.estado):
            tempo_decorrido = time.time() - inicio_tempo
            memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
            return node, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso

        for filho in expandir(node):
            filho_tupla = tuple(map(tuple, filho.estado))
            if filho_tupla not in visitado or filho.custo < visitado[filho_tupla]:
              visitado[filho_tupla] = filho.custo
              heapq.heappush(fronteira, (filho.custo + h(filho), next(contador), filho))


              fringe_size = len(fronteira)
              max_fringe_size = max(max_fringe_size, fringe_size)
              search_depth = filho.custo
              max_search_depth = max(max_search_depth, search_depth)

    memoria_uso = psutil.Process().memory_info().rss / (1024 * 1024)
    return None, nodes_expanded, len(fronteira), max_fringe_size, search_depth, max_search_depth, time.time() - inicio_tempo, memoria_uso

def imprimir_caminho(node):
    if node is None:
        return []
    caminho = []
    while node.pai is not None:
        caminho.append(node.acao)
        node = node.pai
    caminho.reverse()
    return caminho


# Tabuleiro de entrada
tabuleiro = [
    [8, 2, 1],
    [4, 0, 6],
    [5, 3, 7]
]

# [8, 7, 6, 5, 4, 3, 2, 1, 0]
# [0, 5, 1, 6, 4, 3, 8, 2, 7]
# [7, 4, 0, 1, 2, 5, 6, 8, 3]
# [1, 3, 6, 5, 0, 2, 4, 7, 8]

raiz = Node(tabuleiro)


solucao, nodes_expanded, fringe_size, max_fringe_size, search_depth, max_search_depth, tempo_decorrido, memoria_uso = bfs_gulosa(raiz)
solucao_astar, nodes_expanded_astar, fringe_size_astar, max_fringe_size_astar, search_depth_astar, max_search_depth_astar, tempo_decorrido_astar, memoria_uso_astar = BFS_Aestrela(raiz)

if solucao:
    path_to_go_bfs = imprimir_caminho(solucao)
    cost_of_path_bfs = solucao.custo

    print("\n=== Solu√ß√£o por BFS Gulosa ===")
    print(f"Caminho da solu√ß√£o: {' -> '.join(path_to_go_bfs)}")
    print(f"Custo da solu√ß√£o: {cost_of_path_bfs}")
    print(f"N√≥s expandidos: {nodes_expanded}")
    print(f"Tamanho da fronteira: {fringe_size}")
    print(f"Tamanho m√°ximo da fronteira: {max_fringe_size}")
    print(f"Profundidade da busca: {search_depth}")
    print(f"Profundidade m√°xima da busca: {max_search_depth}")
    print(f"Tempo de execu√ß√£o: {tempo_decorrido:.6f} segundos")
    print(f"Uso de mem√≥ria: {memoria_uso:.2f} MB")
else:
    print("Nenhuma solu√ß√£o encontrada utilizando BFS Gulosa.")



if solucao_astar:
    path_to_go_a_star = imprimir_caminho(solucao_astar)
    cost_of_path_a_star = solucao_astar.custo

    print("\n=== Solu√ß√£o por A* ===")
    print(f"Caminho da solu√ß√£o: {' -> '.join(path_to_go_a_star)}")
    print(f"Custo da solu√ß√£o: {cost_of_path_a_star}")
    print(f"N√≥s expandidos: {nodes_expanded_astar}")
    print(f"Tamanho da fronteira: {fringe_size_astar}")
    print(f"Tamanho m√°ximo da fronteira: {max_fringe_size_astar}")
    print(f"Profundidade da busca: {search_depth_astar}")
    print(f"Profundidade m√°xima da busca: {max_search_depth_astar}")
    print(f"Tempo de execu√ß√£o: {tempo_decorrido_astar:.6f} segundos")
    print(f"Uso de mem√≥ria: {memoria_uso_astar:.2f} MB")